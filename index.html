<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù†Ø¸Ø§Ù… Ø§Ù„ÙƒØ´Ù ÙˆØ§Ù„ØªØªØ¨Ø¹ Ø§Ù„Ù…ØªÙ‚Ø¯Ù… PRO - V6.0</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #FF00FF;
            --secondary-color: #00FFFF;
            --accent-color: #39FF14;
            --warning-color: #FFFF00;
            --danger-color: #FF0000;
            --success-color: #00FF00;
            --bg-dark: #000;
            --bg-panel: #0a0a0a;
            --bg-card: #1a1a1a;
            --pro-gold: #FFD700;
            --pro-silver: #C0C0C0;
        }

        body {
            font-family: 'Segoe UI', 'Consolas', 'Courier New', monospace; 
            background: var(--bg-dark); 
            min-height: 100vh;
            padding: 0; 
            color: var(--accent-color);
            overflow-x: hidden;
            background: radial-gradient(circle at 20% 30%, #0f0f23 0%, #000 70%);
        }

        .container {
            max-width: 100%; 
            margin: 0 auto;
            padding: 20px;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 450px;
            gap: 25px;
            animation: fadeIn 1s ease-out;
            transition: grid-template-columns 0.5s ease;
            min-height: calc(100vh - 80px); 
        }
        
        .main-content.full-width {
            grid-template-columns: 1fr;
        }

        header {
            text-align: center;
            margin-bottom: 25px;
            padding-top: 20px;
            animation: fadeInDown 0.8s ease-out;
            position: relative;
        }

        .pro-badge {
            position: absolute;
            top: 10px;
            left: 10px;
            background: linear-gradient(45deg, var(--pro-gold), var(--pro-silver));
            color: #000;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9rem;
            box-shadow: 0 0 15px var(--pro-gold);
        }

        h1 {
            font-size: 3.2rem;
            margin-bottom: 5px;
            color: var(--primary-color);
            text-shadow: 0 0 10px var(--primary-color), 0 0 30px rgba(255, 0, 255, 0.8);
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color), var(--primary-color), var(--pro-gold));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-size: 300% auto;
            animation: textShine 3s linear infinite;
        }

        .subtitle {
            font-size: 1.3rem;
            opacity: 0.9;
            color: var(--pro-gold);
            text-shadow: 0 0 5px var(--pro-gold);
            margin-bottom: 10px;
        }

        .pro-features {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .pro-feature {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid var(--pro-gold);
            border-radius: 8px;
            padding: 5px 10px;
            font-size: 0.8rem;
            color: var(--pro-gold);
        }

        .video-section {
            background: var(--bg-panel);
            border: 3px solid var(--pro-gold);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.8);
            min-height: 100%;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        .video-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 65%, rgba(255, 215, 0, 0.15) 75%, rgba(0, 255, 255, 0.15) 85%, transparent 95%);
            z-index: 1;
            pointer-events: none;
            animation: scanline 2s linear infinite;
        }

        .video-container {
            position: relative;
            width: 100%;
            flex-grow: 1; 
            border-radius: 12px;
            overflow: hidden;
            background: #000;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
        }

        #webcam {
            width: 100%;
            height: 100%; 
            object-fit: contain; 
            display: block;
            z-index: 5;
            filter: contrast(1.1) brightness(1.2); 
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        .fps-counter {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            color: var(--accent-color);
            padding: 8px 15px;
            border-radius: 8px;
            z-index: 15;
            font-size: 16px;
            font-weight: bold;
            border: 1px solid var(--accent-color);
            box-shadow: 0 0 10px var(--accent-color);
        }

        .controls {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
            z-index: 20;
            position: relative;
        }

        button {
            padding: 12px 18px;
            font-size: 1rem;
            border: 2px solid; 
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            background: var(--bg-panel);
            color: #fff;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.7s;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        .btn-success { border-color: var(--success-color); color: var(--success-color); }
        .btn-danger { border-color: var(--danger-color); color: var(--danger-color); }
        .btn-info { border-color: var(--secondary-color); color: var(--secondary-color); }
        .btn-primary { border-color: var(--primary-color); color: var(--primary-color); }
        .btn-toggle { border-color: var(--warning-color); color: var(--warning-color); }
        .btn-aimbot { border-color: var(--accent-color); color: var(--accent-color); }
        .btn-stabilize { border-color: #FF6600; color: #FF6600; }
        .btn-advanced { border-color: #AA00FF; color: #AA00FF; }
        .btn-pro { border-color: var(--pro-gold); color: var(--pro-gold); }

        button:hover {
            box-shadow: 0 0 20px currentColor;
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.98);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .detection-options {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            background: rgba(20, 20, 20, 0.8);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid #333;
        }

        .detection-option {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .detection-option input {
            width: 18px;
            height: 18px;
        }

        .detection-option label {
            font-size: 0.9rem;
            cursor: pointer;
        }

        .system-status {
            margin-top: 20px;
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 15px;
            background: rgba(20, 20, 20, 0.8);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid #333;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1rem;
        }

        .status-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .status-online {
            background-color: var(--success-color);
            box-shadow: 0 0 10px var(--success-color);
            animation: pulse-glow 2s infinite;
        }

        .status-offline {
            background-color: var(--danger-color);
            box-shadow: 0 0 10px var(--danger-color);
        }

        .status-processing {
            background-color: var(--warning-color);
            box-shadow: 0 0 10px var(--warning-color);
            animation: pulse-glow 1s infinite;
        }

        .status-pro {
            background-color: var(--pro-gold);
            box-shadow: 0 0 10px var(--pro-gold);
            animation: pulse-glow 1.5s infinite;
        }

        .settings-panel {
            margin-top: 20px;
            background: rgba(20, 20, 20, 0.8);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #333;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        }

        .settings-panel h3 {
            margin-bottom: 15px;
            color: var(--pro-gold);
            text-align: center;
            font-size: 1.3rem;
        }

        .settings-panel p {
            margin: 8px 0;
            font-size: 1rem;
        }

        .stats-panel {
            background: var(--bg-panel);
            border: 3px solid var(--pro-gold); 
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.8);
            min-height: 100%;
            color: var(--pro-gold);
            font-family: 'Segoe UI', 'Consolas', 'Courier New', monospace;
            position: relative;
            overflow: hidden;
        }
        
        .stats-header {
            font-size: 1.8rem;
            margin-bottom: 25px;
            text-align: center;
            border-bottom: 2px dashed var(--pro-gold);
            padding-bottom: 15px;
            text-shadow: 0 0 10px var(--pro-gold);
            position: relative;
            z-index: 2;
        }

        .stat-item {
            background: var(--bg-card);
            border: 1px solid var(--pro-gold);
            box-shadow: 0 0 12px rgba(255, 215, 0, 0.7);
            margin-bottom: 20px;
            padding: 18px;
            border-radius: 10px;
            position: relative;
            z-index: 2;
            transition: all 0.3s ease;
        }

        .stat-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.9);
        }

        .stat-label {
            font-size: 1rem;
            margin-bottom: 8px;
            color: var(--secondary-color);
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--accent-color);
            text-shadow: 0 0 5px var(--accent-color);
        }

        .detections-list {
            max-height: 350px;
            overflow-y: auto;
            padding: 15px;
            background: rgba(20, 20, 20, 0.8);
            border-radius: 12px;
            border: 1px solid #333;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        }

        .detection-item {
            border: 1px solid;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 12px;
            background: rgba(30, 30, 30, 0.9);
            transition: all 0.3s ease;
        }

        .detection-item:hover {
            transform: scale(1.02);
        }

        .detection-name {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 1.2rem;
        }

        .detection-details {
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .confidence-bar {
            height: 10px;
            background: #333;
            border-radius: 5px;
            overflow: hidden;
        }

        .confidence-fill {
            height: 100%;
            border-radius: 5px;
            transition: width 0.3s ease;
        }

        .loading {
            text-align: center;
            padding: 25px;
            color: #999;
            font-size: 1.1rem;
        }

        .hidden {
            display: none;
        }

        /* ØªØ£Ø«ÙŠØ±Ø§Øª Ø§Ù„Ø­Ø±ÙƒØ© */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes textShine {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @keyframes scanline {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }

        @keyframes pulse-glow {
            0% { box-shadow: 0 0 0 0 rgba(0, 255, 0, 0.7); }
            70% { box-shadow: 0 0 0 15px rgba(0, 255, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 255, 0, 0); }
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* ØªØ­Ø³ÙŠÙ†Ø§Øª Ù„Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„ØµØºÙŠØ±Ø© */
        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            .stats-panel {
                display: none;
            }
            .controls {
                grid-template-columns: 1fr;
            }
            h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="pro-badge">PRO V6.0</div>
            <h1>ğŸ¯ Ù†Ø¸Ø§Ù… Ø§Ù„ØªØªØ¨Ø¹ ÙˆØ§Ù„ÙƒØ´Ù Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠ</h1>
            <p class="subtitle">Ù†Ø³Ø®Ø© PRO Ù…Ø¹ Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª Ù…ØªÙ‚Ø¯Ù…Ø© Ù„Ù„ØªØªØ¨Ø¹ Ø§Ù„Ù…Ø³ØªÙ‚Ø± ÙˆØ§Ù„Ø³Ù„Ø³</p>
            <div class="pro-features">
                <div class="pro-feature">ğŸ”„ ØªØªØ¨Ø¹ ÙØ§Ø¦Ù‚ Ø§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø±</div>
                <div class="pro-feature">ğŸ§  Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù…ØªÙ‚Ø¯Ù…</div>
                <div class="pro-feature">ğŸ¯ ØªØ«Ø¨ÙŠØª Ø­Ø±ÙƒÙŠ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ</div>
                <div class="pro-feature">âš¡ Ù…Ø¹Ø§Ù„Ø¬Ø© ÙØ§Ø¦Ù‚Ø© Ø§Ù„Ø³Ø±Ø¹Ø©</div>
            </div>
        </header>

        <div class="main-content" id="mainContent">
            <div class="video-section">
                <div class="video-container">
                    <div class="fps-counter" id="fps">FPS: 0</div>
                    <video id="webcam" autoplay playsinline></video>
                    <canvas id="canvas"></canvas>
                </div>

                <div class="detection-options">
                    <div class="detection-option">
                        <input type="radio" id="detectAll" name="detectionType" value="all" checked>
                        <label for="detectAll">ğŸ” Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª</label>
                    </div>
                    <div class="detection-option">
                        <input type="radio" id="detectPeople" name="detectionType" value="person">
                        <label for="detectPeople">ğŸ‘¥ Ø§Ù„Ø¨Ø´Ø± ÙÙ‚Ø·</label>
                    </div>
                    <div class="detection-option">
                        <input type="radio" id="detectFaces" name="detectionType" value="face">
                        <label for="detectFaces">ğŸ˜Š Ø§Ù„ÙˆØ¬ÙˆÙ‡ ÙÙ‚Ø·</label>
                    </div>
                    <div class="detection-option">
                        <input type="radio" id="detectBodyParts" name="detectionType" value="body_parts">
                        <label for="detectBodyParts">ğŸ¦µ Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ø¬Ø³Ù…</label>
                    </div>
                </div>

                <div class="controls">
                    <button class="btn-success" id="enableCameraBtn">ğŸ¥ ØªØ´ØºÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§</button>
                    <button class="btn-danger" id="stopCameraBtn" disabled>â¹ï¸ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§</button>
                    <button class="btn-info" id="switchCameraBtn" disabled>ğŸ”„ ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§</button>
                    <button class="btn-pro" id="proTrackingBtn" disabled>ğŸ¦¾ Ø§Ù„ØªØªØ¨Ø¹ PRO</button>
                    <button class="btn-advanced" id="aiAnalysisBtn" disabled>ğŸ¤– ØªØ­Ù„ÙŠÙ„ Ù…ØªÙ‚Ø¯Ù…</button>
                    <button class="btn-stabilize" id="stabilizeBtn" disabled>ğŸ¯ ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ«Ø¨ÙŠØª</button>
                    <button class="btn-aimbot" id="toggleAimbotLinesBtn" disabled>âŒ Ø¥Ø®ÙØ§Ø¡ Ø®Ø·ÙˆØ· Ø§Ù„ØªØªØ¨Ø¹</button>
                    <button class="btn-primary" id="enhancePerformanceBtn" disabled>ğŸš€ ØªØ¹Ø²ÙŠØ² Ø§Ù„Ø£Ø¯Ø§Ø¡</button>
                    <button class="btn-toggle" id="toggleStatsBtn">ğŸ‘ï¸ Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª</button>
                    <button class="btn-info" id="captureBtn" disabled>ğŸ“¸ Ø§Ù„ØªÙ‚Ø§Ø· ØµÙˆØ±Ø©</button>
                </div>
                
                <div class="system-status">
                    <div class="status-indicator"><span>Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ø¸Ø§Ù…:</span><div class="status-dot status-offline" id="systemStatus"></div></div>
                    <div class="status-indicator"><span>Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ:</span><div class="status-dot status-offline" id="aiStatus"></div></div>
                    <div class="status-indicator"><span>Ø§Ù„ØªØªØ¨Ø¹ Ø§Ù„Ù†Ø´Ø·:</span><div class="status-dot status-offline" id="trackingStatus"></div></div>
                    <div class="status-indicator"><span>Ø§Ù„ØªØ«Ø¨ÙŠØª Ø§Ù„Ù†Ø´Ø·:</span><div class="status-dot status-offline" id="stabilizeStatus"></div></div>
                    <div class="status-indicator"><span>Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø²Ø²:</span><div class="status-dot status-offline" id="performanceStatus"></div></div>
                    <div class="status-indicator"><span>ÙˆØ¶Ø¹ PRO:</span><div class="status-dot status-offline" id="proStatus"></div></div>
                </div>

                <div class="settings-panel">
                    <h3>âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù†Ø´Ø·Ø©</h3>
                    <p>Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„ÙƒØ´Ù: <span id="modelType">EfficientDet-Lite4 PRO + Face Detection</span></p>
                    <p>Ù†ÙˆØ¹ Ø§Ù„ÙƒØ´Ù: <span id="detectionTypeText">Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª</span></p>
                    <p>Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…: <span id="advancedAnalysisStatus" style="color:#FFFF00;">ØºÙŠØ± Ù†Ø´Ø·</span></p>
                    <p>Ø§Ù„ØªØ«Ø¨ÙŠØª Ø§Ù„Ù†Ø´Ø·: <span id="stabilizeActiveStatus" style="color:#FFFF00;">ØºÙŠØ± Ù†Ø´Ø·</span></p>
                    <p>Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø²Ø²: <span id="performanceStatusText" style="color:#FFFF00;">ØºÙŠØ± Ù†Ø´Ø·</span></p>
                    <p>ÙˆØ¶Ø¹ PRO: <span id="proStatusText" style="color:#FFFF00;">ØºÙŠØ± Ù†Ø´Ø·</span></p>
                </div>
            </div>

            <div class="stats-panel" id="statsPanel"> 
                <h2 class="stats-header">ğŸ“Š Ù„ÙˆØ­Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠØ©</h2>

                <div class="stat-item">
                    <div class="stat-label">Ø§Ù„Ø£Ø´ÙŠØ§Ø¡ Ø§Ù„Ù…ÙƒØªØ´ÙØ© Ø­Ø§Ù„ÙŠØ§Ù‹</div>
                    <div class="stat-value" id="objectCount">0</div>
                </div>

                <div class="stat-item">
                    <div class="stat-label">Ù…Ø¹Ø¯Ù„ Ø¥Ø·Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© (FPS)</div>
                    <div class="stat-value" id="fpsValue">0</div>
                </div>
                
                <div class="stat-item">
                    <div class="stat-label">Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ù…ØªØªØ¨Ø¹Ø©</div>
                    <div class="stat-value" id="trackedObjects">0</div>
                </div>
                
                <div class="stat-item">
                    <div class="stat-label">Ù†Ù…Ø· Ø§Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ù…Ø³Ø¬Ù„</div>
                    <div class="stat-value" id="movementPattern">ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ</div>
                </div>
                
                <div class="stat-item">
                    <div class="stat-label">Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø±</div>
                    <div class="stat-value" id="stabilityLevel">0%</div>
                </div>
                
                <div class="stat-item">
                    <div class="stat-label">ÙˆÙ‚Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© (Ù…Ù„Ù„ÙŠ Ø«Ø§Ù†ÙŠØ©)</div>
                    <div class="stat-value" id="processingTime">0</div>
                </div>

                <h3 style="margin-top: 25px; margin-bottom: 15px; text-align: center; color: var(--secondary-color);">ğŸ¯ Ø³Ø¬Ù„ Ø§Ù„ØªØªØ¨Ø¹ Ø§Ù„Ù…ØªÙ‚Ø¯Ù… (Live Feed)</h3>
                <div class="detections-list" id="detectionsList">
                    <div class="loading"><p>ÙÙŠ Ø§Ù†ØªØ¸Ø§Ø± ØªØ´ØºÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§...</p></div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { 
            ObjectDetector, 
            FaceDetector,
            FilesetResolver 
        } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest";

        // Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©
        let objectDetector;
        let faceDetector;
        const video = document.getElementById('webcam'); 
        const canvas = document.getElementById('canvas'); 
        const ctx = canvas.getContext('2d');
        let isDetecting = false;
        let currentStream = null;
        let useFrontCamera = false;
        let lastFrameTime = Date.now();
        let frameCount = 0;
        let fps = 0;
        let videoLoadedListener = null;
        
        let advancedAnalysis = false; 
        let showAimbotLines = true;
        let stabilizationActive = false;
        let performanceEnhanced = false;
        let proTrackingActive = false; // ÙˆØ¶Ø¹ PRO Ø§Ù„Ø¬Ø¯ÙŠØ¯
        
        // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ÙƒØ´Ù
        let detectionType = 'all'; // all, person, face, body_parts
        
        let trackedObjects = new Map(); 
        let objectHistory = new Map(); 
        let movementPatterns = {};
        let stabilizedObjects = new Map();
        
        // Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Kalman Filter PRO Ù„Ù„ØªØªØ¨Ø¹ Ø§Ù„Ù…Ø³ØªÙ‚Ø±
        class ProKalmanFilter {
            constructor() {
                this.Q = 0.05;  // Ø¶Ø¬ÙŠØ¬ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© (Ù…Ø®ÙØ¶ Ù„Ù„Ø³Ù„Ø§Ø³Ø©)
                this.R = 0.08;  // Ø¶Ø¬ÙŠØ¬ Ø§Ù„Ù‚ÙŠØ§Ø³ (Ù…Ø­Ø³Ù‘Ù†)
                this.P = 1;     // Ø®Ø·Ø£ Ø§Ù„ØªÙ‚Ø¯ÙŠØ±
                this.X = 0;     // Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ù‚Ø¯Ø±Ø©
                this.K = 0;     // ÙƒØ§Ù„Ù…Ø§Ù† ØºÙŠÙ†
                this.velocity = 0; // Ø³Ø±Ø¹Ø© Ø§Ù„ØªØªØ¨Ø¹
                this.acceleration = 0; // ØªØ³Ø§Ø±Ø¹ Ø§Ù„ØªØªØ¨Ø¹
                this.smoothFactor = 0.85; // Ø¹Ø§Ù…Ù„ Ø§Ù„ØªÙ†Ø¹ÙŠÙ… Ø§Ù„Ø¥Ø¶Ø§ÙÙŠ
            }
            
            filter(measurement, dt = 1) {
                // Ù…Ø±Ø­Ù„Ø© Ø§Ù„ØªÙ†Ø¨Ø¤ Ù…Ø¹ Ù…Ø±Ø§Ø¹Ø§Ø© Ø§Ù„Ø³Ø±Ø¹Ø©
                this.X = this.X + this.velocity * dt;
                this.P = this.P + this.Q;
                
                // Ù…Ø±Ø­Ù„Ø© Ø§Ù„ØªØ­Ø¯ÙŠØ«
                this.K = this.P / (this.P + this.R);
                const innovation = measurement - this.X;
                this.X = this.X + this.K * innovation;
                this.P = (1 - this.K) * this.P;
                
                // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ø±Ø¹Ø©
                this.velocity = this.smoothFactor * this.velocity + (1 - this.smoothFactor) * innovation / dt;
                
                // ØªØ·Ø¨ÙŠÙ‚ ØªÙ†Ø¹ÙŠÙ… Ø¥Ø¶Ø§ÙÙŠ Ù„Ù„Ù†ØªÙŠØ¬Ø©
                this.X = this.smoothFactor * this.X + (1 - this.smoothFactor) * measurement;
                
                return this.X;
            }
            
            reset() {
                this.P = 1;
                this.X = 0;
                this.K = 0;
                this.velocity = 0;
                this.acceleration = 0;
            }
        }
        
        // Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ù…Ø·Ø§Ø¨Ù‚Ø© Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª PRO
        class ProObjectMatcher {
            constructor() {
                this.maxDistance = 80; // Ø£Ù‚ØµÙ‰ Ù…Ø³Ø§ÙØ© Ù„Ù„Ù…Ø·Ø§Ø¨Ù‚Ø© (Ù…Ø®ÙØ¶Ø© Ù„Ù„Ø¯Ù‚Ø©)
                this.minConfidence = 0.4; // Ø£Ù‚Ù„ Ø«Ù‚Ø© Ù„Ù„Ù…Ø·Ø§Ø¨Ù‚Ø© (Ù…Ø±ÙÙˆØ¹Ø© Ù„Ù„Ø¯Ù‚Ø©)
                this.sizeWeight = 0.4; // ÙˆØ²Ù† Ø§Ù„Ø­Ø¬Ù… ÙÙŠ Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚Ø©
                this.positionWeight = 0.5; // ÙˆØ²Ù† Ø§Ù„Ù…ÙˆØ¶Ø¹ ÙÙŠ Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚Ø©
                this.categoryWeight = 0.1; // ÙˆØ²Ù† Ø§Ù„ÙØ¦Ø© ÙÙŠ Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚Ø©
            }
            
            // Ø­Ø³Ø§Ø¨ Ø¯Ø±Ø¬Ø© Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚Ø© Ø¨ÙŠÙ† ÙƒØ§Ø¦Ù†ÙŠÙ†
            calculateMatchScore(obj1, obj2) {
                // Ø§Ù„Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ† Ø§Ù„Ù…Ø±Ø§ÙƒØ²
                const dx = obj1.position.x - obj2.position.x;
                const dy = obj1.position.y - obj2.position.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Ø§Ù„ØªØ´Ø§Ø¨Ù‡ ÙÙŠ Ø§Ù„Ø­Ø¬Ù…
                const sizeSimilarity = 1 - Math.abs(obj1.size.width - obj2.size.width) / Math.max(obj1.size.width, obj2.size.width);
                
                // Ø§Ù„ØªØ´Ø§Ø¨Ù‡ ÙÙŠ Ø§Ù„ÙØ¦Ø©
                const categoryMatch = obj1.category === obj2.category ? 1 : 0;
                
                // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¯Ø±Ø¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© Ù…Ø¹ Ø§Ù„Ø£ÙˆØ²Ø§Ù†
                const distanceScore = Math.max(0, 1 - distance / this.maxDistance);
                const finalScore = (distanceScore * this.positionWeight) + 
                                  (sizeSimilarity * this.sizeWeight) + 
                                  (categoryMatch * this.categoryWeight);
                
                return finalScore;
            }
            
            // Ù…Ø·Ø§Ø¨Ù‚Ø© Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø¨ÙŠÙ† Ø§Ù„Ø¥Ø·Ø§Ø±Ø§Øª
            matchObjects(currentObjects, previousObjects) {
                const matches = new Map();
                const usedCurrent = new Set();
                const usedPrevious = new Set();
                
                // Ø¥ÙŠØ¬Ø§Ø¯ Ø£ÙØ¶Ù„ Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚Ø§Øª
                previousObjects.forEach((prevObj, prevId) => {
                    let bestMatchId = null;
                    let bestScore = 0;
                    
                    currentObjects.forEach((currObj, currId) => {
                        if (usedCurrent.has(currId)) return;
                        
                        const score = this.calculateMatchScore(prevObj, currObj);
                        if (score > bestScore && score >= this.minConfidence) {
                            bestScore = score;
                            bestMatchId = currId;
                        }
                    });
                    
                    if (bestMatchId) {
                        matches.set(prevId, {
                            currentId: bestMatchId,
                            score: bestScore
                        });
                        usedCurrent.add(bestMatchId);
                        usedPrevious.add(prevId);
                    }
                });
                
                return matches;
            }
        }

        const colors = [
            '#FF00FF', // Ù…Ø§Ø¬Ù†ØªØ§ (Ø£Ø³Ø§Ø³ÙŠ)
            '#00FFFF', // Ø³Ù…Ø§ÙˆÙŠ
            '#FFFF00', // Ø£ØµÙØ±
            '#00FF00', // Ø£Ø®Ø¶Ø±
            '#FF0066', // ÙˆØ±Ø¯ÙŠ
            '#00AAFF', // Ø£Ø²Ø±Ù‚ Ø³Ø§Ø·Ø¹
            '#FF6600', // Ø¨Ø±ØªÙ‚Ø§Ù„ÙŠ
            '#39FF14', // Ø£Ø®Ø¶Ø± Ù‡Ø§ÙƒØ±
            '#AA00FF', // Ø¨Ù†ÙØ³Ø¬ÙŠ
            '#00FFAA', // ØªØ±ÙƒÙˆØ§Ø²
            '#FFD700', // Ø°Ù‡Ø¨ÙŠ PRO
            '#C0C0C0'  // ÙØ¶ÙŠ PRO
        ];

        // Ø¥Ù†Ø´Ø§Ø¡ ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª PRO
        const proObjectMatcher = new ProObjectMatcher();
        const proKalmanFilters = new Map(); // Ù…Ø±Ø´Ø­Ø§Øª ÙƒØ§Ù„Ù…Ø§Ù† PRO Ù„ÙƒÙ„ ÙƒØ§Ø¦Ù†

        // ØªÙ‡ÙŠØ¦Ø© Ù†Ù…Ø§Ø°Ø¬ MediaPipe Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
        async function initializeDetectors() {
            try {
                updateSystemStatus('systemStatus', 'processing');
                
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
                );

                // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†Ù…Ø§Ø°Ø¬ Ù…Ø­Ù„ÙŠØ© Ø¨Ø¯ÙŠÙ„Ø© Ù…Ù† CDN Ù…ÙˆØ«ÙˆÙ‚
                // Ù‡Ø°Ù‡ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ù…ØªÙˆØ§ÙÙ‚Ø© Ù…Ø¹ Ø§Ù„Ø¥ØµØ¯Ø§Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ Ù…Ù† MediaPipe
                const objectModelPath = 'https://storage.googleapis.com/mediapipe-assets/object_detector.tflite?generation=1679941036644449';
                const faceModelPath = 'https://storage.googleapis.com/mediapipe-assets/face_detector.tflite?generation=1679940890656775';

                // ØªÙ‡ÙŠØ¦Ø© ÙƒØ§Ø´Ù Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª PRO
                objectDetector = await ObjectDetector.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: objectModelPath,
                        delegate: "GPU" 
                    },
                    scoreThreshold: performanceEnhanced ? 0.12 : 0.08, 
                    maxResults: performanceEnhanced ? 50 : 40, 
                    runningMode: 'VIDEO'
                });

                // ØªÙ‡ÙŠØ¦Ø© ÙƒØ§Ø´Ù Ø§Ù„ÙˆØ¬ÙˆÙ‡ PRO
                faceDetector = await FaceDetector.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: faceModelPath,
                        delegate: "GPU"
                    },
                    runningMode: 'VIDEO'
                });

                console.log('âœ… ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠØ© Ø¨Ù†Ø¬Ø§Ø­');
                updateSystemStatus('systemStatus', 'online');
                updateSystemStatus('aiStatus', 'online');
                
            } catch (error) {
                console.error('âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬:', error);
                
                // Ø­Ù„ Ø¨Ø¯ÙŠÙ„: Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†Ù…Ø§Ø°Ø¬ Ø£Ø¨Ø³Ø· Ø¥Ø°Ø§ ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
                try {
                    console.log('ğŸ”„ Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ­Ù…ÙŠÙ„ Ù†Ù…Ø§Ø°Ø¬ Ø¨Ø¯ÙŠÙ„Ø©...');
                    
                    const vision = await FilesetResolver.forVisionTasks(
                        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
                    );

                    // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ù…ØªÙˆÙØ±Ø© Ø¯Ø§Ø¦Ù…Ø§Ù‹
                    objectDetector = await ObjectDetector.createFromOptions(vision, {
                        baseOptions: {
                            modelAssetPath: 'https://storage.googleapis.com/mediapipe-tasks/object_detector/efficientdet_lite0_uint8.tflite',
                            delegate: "GPU" 
                        },
                        scoreThreshold: 0.3,
                        maxResults: 50,
                        runningMode: 'VIDEO'
                    });

                    faceDetector = await FaceDetector.createFromOptions(vision, {
                        baseOptions: {
                            modelAssetPath: 'https://storage.googleapis.com/mediapipe-tasks/face_detector/blaze_face_short_range_uint8.tflite',
                            delegate: "GPU"
                        },
                        runningMode: 'VIDEO'
                    });

                    console.log('âœ… ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„Ø¨Ø¯ÙŠÙ„Ø© Ø¨Ù†Ø¬Ø§Ø­');
                    updateSystemStatus('systemStatus', 'online');
                    updateSystemStatus('aiStatus', 'online');
                    
                } catch (fallbackError) {
                    console.error('âŒ ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„Ø¨Ø¯ÙŠÙ„Ø© Ø£ÙŠØ¶Ø§Ù‹:', fallbackError);
                    updateSystemStatus('systemStatus', 'offline');
                    updateSystemStatus('aiStatus', 'offline');
                    
                    // Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© ØªÙˆØ¶ÙŠØ­ÙŠØ© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
                    alert('ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ. ÙŠØ±Ø¬Ù‰:\n\n1. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§ØªØµØ§Ù„ Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª\n2. ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙØ­Ø© ÙˆØ§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰\n3. Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…ØªØµÙØ­ Ø­Ø¯ÙŠØ« ÙŠØ¯Ø¹Ù… WebAssembly');
                }
            }
        }
        
        // ØªØ­Ø¯ÙŠØ« Ù†ÙˆØ¹ Ø§Ù„ÙƒØ´Ù Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        function updateDetectionType() {
            const selectedOption = document.querySelector('input[name="detectionType"]:checked');
            detectionType = selectedOption.value;
            
            const detectionTypeText = document.getElementById('detectionTypeText');
            switch(detectionType) {
                case 'all':
                    detectionTypeText.textContent = 'Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª';
                    break;
                case 'person':
                    detectionTypeText.textContent = 'Ø§Ù„Ø¨Ø´Ø± ÙÙ‚Ø·';
                    break;
                case 'face':
                    detectionTypeText.textContent = 'Ø§Ù„ÙˆØ¬ÙˆÙ‡ ÙÙ‚Ø·';
                    break;
                case 'body_parts':
                    detectionTypeText.textContent = 'Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ø¬Ø³Ù…';
                    break;
            }
            
            // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„ØªØªØ¨Ø¹ Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ù†ÙˆØ¹ Ø§Ù„ÙƒØ´Ù
            if (isDetecting) {
                trackedObjects.clear();
                objectHistory.clear();
                movementPatterns = {};
                stabilizedObjects.clear();
                proKalmanFilters.clear();
            }
        }
        
        // Ø¯Ø§Ù„Ø© ØªÙØ¹ÙŠÙ„/ØªØ¹Ø·ÙŠÙ„ ÙˆØ¶Ø¹ PRO
        function toggleProTracking() {
            proTrackingActive = !proTrackingActive;
            const btn = document.getElementById('proTrackingBtn');
            const status = document.getElementById('proStatusText');
            
            if (proTrackingActive) {
                btn.textContent = 'ğŸ¦¾ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØªØ¨Ø¹ PRO';
                btn.classList.remove('btn-pro');
                btn.classList.add('btn-danger');
                status.textContent = 'Ù†Ø´Ø·';
                status.style.color = '#FFD700';
                updateSystemStatus('proStatus', 'pro');
                
                // ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠØ© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
                if (!stabilizationActive) toggleStabilization();
                if (!performanceEnhanced) togglePerformanceEnhancement();
                
                console.log('ğŸ¦¾ ØªÙ… ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ PRO Ù…Ø¹ Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª Ù…ØªÙ‚Ø¯Ù…Ø©');
            } else {
                btn.textContent = 'ğŸ¦¾ Ø§Ù„ØªØªØ¨Ø¹ PRO';
                btn.classList.remove('btn-danger');
                btn.classList.add('btn-pro');
                status.textContent = 'ØºÙŠØ± Ù†Ø´Ø·';
                status.style.color = '#FFFF00';
                updateSystemStatus('proStatus', 'offline');
            }
        }
        
        // Ø¯Ø§Ù„Ø© ØªÙØ¹ÙŠÙ„/ØªØ¹Ø·ÙŠÙ„ ØªØ¹Ø²ÙŠØ² Ø§Ù„Ø£Ø¯Ø§Ø¡
        function togglePerformanceEnhancement() {
            performanceEnhanced = !performanceEnhanced;
            const btn = document.getElementById('enhancePerformanceBtn');
            const status = document.getElementById('performanceStatusText');
            const performanceStatus = document.getElementById('performanceStatus');
            
            if (performanceEnhanced) {
                btn.textContent = 'ğŸš€ Ø¥ÙŠÙ‚Ø§Ù ØªØ¹Ø²ÙŠØ² Ø§Ù„Ø£Ø¯Ø§Ø¡';
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-success');
                status.textContent = 'Ù†Ø´Ø·';
                status.style.color = '#00FF00';
                updateSystemStatus('performanceStatus', 'online');
                
                // Ø¥Ø¹Ø§Ø¯Ø© ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ÙƒØ§Ø´Ù ÙˆØ§Ù„Ø°Ø§ÙƒØ±Ø©
                if ((objectDetector || faceDetector) && isDetecting) {
                    setTimeout(() => {
                        initializeDetectors().then(() => {
                            console.log('ğŸ”„ ØªÙ… ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ø¹Ø§Ù„ÙŠ');
                        });
                    }, 100);
                }
            } else {
                btn.textContent = 'ğŸš€ ØªØ¹Ø²ÙŠØ² Ø§Ù„Ø£Ø¯Ø§Ø¡';
                btn.classList.remove('btn-success');
                btn.classList.add('btn-primary');
                status.textContent = 'ØºÙŠØ± Ù†Ø´Ø·';
                status.style.color = '#FFFF00';
                updateSystemStatus('performanceStatus', 'offline');
            }
        }
        
        // Ø¯Ø§Ù„Ø© ØªÙØ¹ÙŠÙ„/ØªØ¹Ø·ÙŠÙ„ Ø§Ù„ØªØ«Ø¨ÙŠØª
        function toggleStabilization() {
            stabilizationActive = !stabilizationActive;
            const btn = document.getElementById('stabilizeBtn');
            const status = document.getElementById('stabilizeActiveStatus');
            
            if (stabilizationActive) {
                btn.textContent = 'ğŸ¯ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ«Ø¨ÙŠØª';
                btn.classList.remove('btn-stabilize');
                btn.classList.add('btn-danger');
                status.textContent = 'Ù†Ø´Ø·';
                status.style.color = '#00FF00';
                updateSystemStatus('stabilizeStatus', 'online');
            } else {
                btn.textContent = 'ğŸ¯ ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ«Ø¨ÙŠØª';
                btn.classList.remove('btn-danger');
                btn.classList.add('btn-stabilize');
                status.textContent = 'ØºÙŠØ± Ù†Ø´Ø·';
                status.style.color = '#FFFF00';
                updateSystemStatus('stabilizeStatus', 'offline');
                stabilizedObjects.clear();
                proKalmanFilters.clear();
            }
        }
        
        // Ø¯Ø§Ù„Ø© ØªØ¨Ø¯ÙŠÙ„ Ø®Ø·ÙˆØ· Ø§Ù„ØªØªØ¨Ø¹
        function toggleAimbotLines() {
            showAimbotLines = !showAimbotLines;
            const btn = document.getElementById('toggleAimbotLinesBtn');
            if (showAimbotLines) {
                btn.textContent = 'âŒ Ø¥Ø®ÙØ§Ø¡ Ø®Ø·ÙˆØ· Ø§Ù„ØªØªØ¨Ø¹';
                btn.classList.remove('btn-danger');
                btn.classList.add('btn-aimbot');
            } else {
                btn.textContent = 'âœ… Ø¥Ø¸Ù‡Ø§Ø± Ø®Ø·ÙˆØ· Ø§Ù„ØªØªØ¨Ø¹';
                btn.classList.remove('btn-aimbot');
                btn.classList.add('btn-danger');
            }
        }

        function videoLoadedHandler() {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            isDetecting = true;
            predictWebcam();
            
            // ØªÙØ¹ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø¨Ø¹Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
            document.getElementById('enableCameraBtn').disabled = true;
            document.getElementById('stopCameraBtn').disabled = false;
            document.getElementById('switchCameraBtn').disabled = false;
            document.getElementById('captureBtn').disabled = false;
            document.getElementById('aiAnalysisBtn').disabled = false;
            document.getElementById('toggleAimbotLinesBtn').disabled = false;
            document.getElementById('stabilizeBtn').disabled = false;
            document.getElementById('enhancePerformanceBtn').disabled = false;
            document.getElementById('proTrackingBtn').disabled = false;

            updateSystemStatus('trackingStatus', 'online');
        }

        async function enableCamera() {
            if (!objectDetector && !faceDetector) {
                alert('Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„ØªØªØ¨Ø¹ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±...');
                return;
            }
            
            if (videoLoadedListener) {
                 video.removeEventListener('loadeddata', videoLoadedListener);
            }

            const constraints = {
                video: {
                    facingMode: useFrontCamera ? 'user' : 'environment',
                    width: { ideal: 1920 },
                    height: { ideal: 1080 },
                    frameRate: { ideal: 60, max: 60 }
                }
            };

            try {
                if (currentStream) {
                    currentStream.getTracks().forEach(track => track.stop());
                }

                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = currentStream;
                
                videoLoadedListener = videoLoadedHandler;
                video.addEventListener('loadeddata', videoLoadedListener, { once: true }); 
                
                video.play();

            } catch (error) {
                console.error('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§:', error);
                let errorMessage = 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø£Ø°ÙˆÙ†Ø§Øª.';
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    errorMessage = 'ØªÙ… Ø±ÙØ¶ Ø¥Ø°Ù† Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ù‡ ÙÙŠ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…ØªØµÙØ­.';
                } else if (error.name === 'NotReadableError') {
                     errorMessage = 'Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ù…Ø³ØªØ®Ø¯Ù…Ø© Ø¨Ø§Ù„ÙØ¹Ù„ Ù…Ù† Ù‚Ø¨Ù„ ØªØ·Ø¨ÙŠÙ‚ Ø£Ùˆ Ø¹Ù„Ø§Ù…Ø© ØªØ¨ÙˆÙŠØ¨ Ø£Ø®Ø±Ù‰.';
                } else if (error.name === 'SecurityError' && location.protocol !== 'https:') {
                    errorMessage = 'âš ï¸ ÙŠØ¬Ø¨ ØªØ´ØºÙŠÙ„ Ù‡Ø°Ø§ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø¹Ø¨Ø± Ø§ØªØµØ§Ù„ Ø¢Ù…Ù† (HTTPS) Ø£Ùˆ Ø®Ø§Ø¯Ù… Ù…Ø­Ù„ÙŠ.';
                } else if (error.name === 'OverconstrainedError') {
                    errorMessage = 'Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ù„Ø§ ØªØ¯Ø¹Ù… 60 Ø¥Ø·Ø§Ø±/Ø«Ø§Ù†ÙŠØ©. Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø£Ø¹Ù„Ù‰ Ù…Ø¹Ø¯Ù„ Ù…ØªØ§Ø­.';
                    // Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù…Ø¹ Ù‚ÙŠÙˆØ¯ Ø£Ù‚Ù„
                    constraints.video.frameRate = { ideal: 30, max: 60 };
                    setTimeout(enableCamera, 100);
                    return;
                }
                alert(errorMessage);
                
                document.getElementById('enableCameraBtn').disabled = false;
                document.getElementById('stopCameraBtn').disabled = true;
                document.getElementById('switchCameraBtn').disabled = true;
                document.getElementById('captureBtn').disabled = true;
                document.getElementById('aiAnalysisBtn').disabled = true;
                document.getElementById('toggleAimbotLinesBtn').disabled = true;
                document.getElementById('stabilizeBtn').disabled = true;
                document.getElementById('enhancePerformanceBtn').disabled = true;
                document.getElementById('proTrackingBtn').disabled = true;

                updateSystemStatus('trackingStatus', 'offline');
            }
        }

        function stopCamera() {
            isDetecting = false;
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }
            video.srcObject = null;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (videoLoadedListener) {
                 video.removeEventListener('loadeddata', videoLoadedListener);
            }
            
            document.getElementById('enableCameraBtn').disabled = false;
            document.getElementById('stopCameraBtn').disabled = true;
            document.getElementById('switchCameraBtn').disabled = true;
            document.getElementById('captureBtn').disabled = true;
            document.getElementById('aiAnalysisBtn').disabled = true;
            document.getElementById('toggleAimbotLinesBtn').disabled = true;
            document.getElementById('stabilizeBtn').disabled = true;
            document.getElementById('enhancePerformanceBtn').disabled = true;
            document.getElementById('proTrackingBtn').disabled = true;

            document.getElementById('detectionsList').innerHTML = '<div class="loading"><p>ÙÙŠ Ø§Ù†ØªØ¸Ø§Ø± ØªØ´ØºÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§...</p></div>';
            document.getElementById('objectCount').textContent = '0';
            document.getElementById('fpsValue').textContent = '0';
            document.getElementById('movementPattern').textContent = 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ';
            document.getElementById('stabilityLevel').textContent = '0%';
            document.getElementById('processingTime').textContent = '0';
            
            updateSystemStatus('trackingStatus', 'offline');
            updateSystemStatus('stabilizeStatus', 'offline');
            updateSystemStatus('performanceStatus', 'offline');
            updateSystemStatus('proStatus', 'offline');
            
            trackedObjects.clear();
            objectHistory.clear();
            movementPatterns = {};
            stabilizedObjects.clear();
            proKalmanFilters.clear();
        }

        function switchCamera() {
            stopCamera(); 
            useFrontCamera = !useFrontCamera;
            setTimeout(enableCamera, 500); 
        }

        function toggleAdvancedAnalysis() {
            advancedAnalysis = !advancedAnalysis;
            document.getElementById('advancedAnalysisStatus').textContent = advancedAnalysis ? 'Ù†Ø´Ø·' : 'ØºÙŠØ± Ù†Ø´Ø·';
            document.getElementById('aiAnalysisBtn').textContent = advancedAnalysis ? 'ğŸ¤– Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…' : 'ğŸ¤– ØªØ­Ù„ÙŠÙ„ Ù…ØªÙ‚Ø¯Ù…';
            
            if (advancedAnalysis) {
                document.getElementById('aiAnalysisBtn').classList.add('btn-primary');
                document.getElementById('aiAnalysisBtn').classList.remove('btn-advanced');
            } else {
                document.getElementById('aiAnalysisBtn').classList.remove('btn-primary');
                document.getElementById('aiAnalysisBtn').classList.add('btn-advanced');
            }
            
            if (!advancedAnalysis) {
                 trackedObjects.clear();
                 objectHistory.clear();
                 movementPatterns = {};
                 document.getElementById('trackedObjects').textContent = '0';
                 document.getElementById('movementPattern').textContent = 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ';
            }
        }

        // Ø¯Ø§Ù„Ø© Ø§Ù„ÙƒØ´Ù Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„Ù…Ø­Ø¯Ø¯
        async function performDetection() {
            const detections = [];
            const currentTime = performance.now();
            
            try {
                // Ø§Ù„ÙƒØ´Ù Ø¹Ù† Ø§Ù„ÙˆØ¬ÙˆÙ‡ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù†ÙˆØ¹ "ÙˆØ¬Ù‡" Ø£Ùˆ "ÙƒÙ„"
                if (detectionType === 'face' || detectionType === 'all') {
                    if (faceDetector) {
                        const faceResults = faceDetector.detectForVideo(video, currentTime);
                        if (faceResults.detections) {
                            faceResults.detections.forEach(face => {
                                detections.push({
                                    ...face,
                                    categoryName: 'face',
                                    displayName: 'ÙˆØ¬Ù‡'
                                });
                            });
                        }
                    }
                }
                
                // Ø§Ù„ÙƒØ´Ù Ø¹Ù† Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù†ÙˆØ¹ Ù„ÙŠØ³ "ÙˆØ¬Ù‡" ÙÙ‚Ø·
                if (detectionType !== 'face') {
                    if (objectDetector) {
                        const objectResults = objectDetector.detectForVideo(video, currentTime);
                        if (objectResults.detections) {
                            objectResults.detections.forEach(obj => {
                                const category = obj.categories[0];
                                
                                // ØªØµÙÙŠØ© Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†ÙˆØ¹ Ø§Ù„ÙƒØ´Ù Ø§Ù„Ù…Ø·Ù„ÙˆØ¨
                                if (detectionType === 'all' || 
                                    (detectionType === 'person' && category.categoryName === 'person') ||
                                    (detectionType === 'body_parts' && 
                                     ['hand', 'foot', 'head', 'arm', 'leg'].includes(category.categoryName))) {
                                    
                                    detections.push({
                                        ...obj,
                                        categoryName: category.categoryName,
                                        displayName: getArabicCategoryName(category.categoryName),
                                        confidence: category.score
                                    });
                                }
                            });
                        }
                    }
                }
            } catch (error) {
                console.error('Ø®Ø·Ø£ ÙÙŠ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ÙƒØ´Ù:', error);
            }
            
            return detections;
        }
        
        // ØªØ±Ø¬Ù…Ø© Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„ÙØ¦Ø§Øª Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
        function getArabicCategoryName(englishName) {
            const categoryMap = {
                'person': 'Ø´Ø®Øµ',
                'face': 'ÙˆØ¬Ù‡',
                'hand': 'ÙŠØ¯',
                'head': 'Ø±Ø£Ø³',
                'arm': 'Ø°Ø±Ø§Ø¹',
                'leg': 'Ø³Ø§Ù‚',
                'foot': 'Ù‚Ø¯Ù…',
                'car': 'Ø³ÙŠØ§Ø±Ø©',
                'cat': 'Ù‚Ø·Ø©',
                'dog': 'ÙƒÙ„Ø¨',
                'bird': 'Ø·Ø§Ø¦Ø±',
                'chair': 'ÙƒØ±Ø³ÙŠ',
                'table': 'Ø·Ø§ÙˆÙ„Ø©',
                'phone': 'Ù‡Ø§ØªÙ',
                'book': 'ÙƒØªØ§Ø¨'
            };
            
            return categoryMap[englishName] || englishName;
        }

        // Ø¯Ø§Ù„Ø© Ù…Ø·Ø§Ø¨Ù‚Ø© Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ù…Ø«Ø¨ØªØ© Ù…Ø¹ Ø§Ù„Ù…ÙƒØªØ´ÙØ© Ø­Ø¯ÙŠØ«Ø§Ù‹ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Kalman Filter PRO
        function matchStabilizedObjects(detections) {
            if (!stabilizationActive) return;
            
            const currentTime = Date.now();
            const currentDetections = new Map();
            
            // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø§ÙƒØªØ´Ø§ÙØ§Øª Ø¥Ù„Ù‰ Ø®Ø±ÙŠØ·Ø©
            detections.forEach((detection, index) => {
                const bbox = detection.boundingBox;
                
                const centerX = bbox.originX + bbox.width / 2;
                const centerY = bbox.originY + bbox.height / 2;
                
                currentDetections.set(`${detection.categoryName}-${index}`, {
                    category: detection.categoryName,
                    displayName: detection.displayName,
                    confidence: detection.confidence || (detection.categories && detection.categories[0] ? detection.categories[0].score : 0.5),
                    position: { x: centerX, y: centerY },
                    size: { width: bbox.width, height: bbox.height },
                    timestamp: currentTime
                });
            });
            
            // Ù…Ø·Ø§Ø¨Ù‚Ø© Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠØ©
            const matches = proObjectMatcher.matchObjects(currentDetections, stabilizedObjects);
            
            // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ù…Ø«Ø¨ØªØ©
            matches.forEach((match, stabilizedId) => {
                const currentObj = currentDetections.get(match.currentId);
                const stabilizedObj = stabilizedObjects.get(stabilizedId);
                
                // ØªÙ‡ÙŠØ¦Ø© Ù…Ø±Ø´Ø­ ÙƒØ§Ù„Ù…Ø§Ù† PRO Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
                if (!proKalmanFilters.has(stabilizedId)) {
                    proKalmanFilters.set(stabilizedId, {
                        x: new ProKalmanFilter(),
                        y: new ProKalmanFilter(),
                        width: new ProKalmanFilter(),
                        height: new ProKalmanFilter()
                    });
                }
                
                const filters = proKalmanFilters.get(stabilizedId);
                const dt = (currentTime - stabilizedObj.lastSeen) / 1000 || 0.033; // Ø§Ù„ÙØ§Ø±Ù‚ Ø§Ù„Ø²Ù…Ù†ÙŠ Ø¨Ø§Ù„Ø«ÙˆØ§Ù†ÙŠ
                
                // ØªØ·Ø¨ÙŠÙ‚ Ù…Ø±Ø´Ø­ ÙƒØ§Ù„Ù…Ø§Ù† PRO Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙˆØ¶Ø¹ ÙˆØ§Ù„Ø­Ø¬Ù…
                stabilizedObj.position.x = filters.x.filter(currentObj.position.x, dt);
                stabilizedObj.position.y = filters.y.filter(currentObj.position.y, dt);
                stabilizedObj.size.width = filters.width.filter(currentObj.size.width, dt);
                stabilizedObj.size.height = filters.height.filter(currentObj.size.height, dt);
                
                stabilizedObj.confidence = currentObj.confidence;
                stabilizedObj.lastSeen = currentTime;
                stabilizedObj.stability += 0.15; // Ø²ÙŠØ§Ø¯Ø© Ø£Ø³Ø±Ø¹ ÙÙŠ Ø§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø±
                stabilizedObj.stability = Math.min(stabilizedObj.stability, 1);
                
                // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ÙƒØ§Ø¦Ù† Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚ Ù…Ù† Ø§Ù„Ø§ÙƒØªØ´Ø§ÙØ§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©
                currentDetections.delete(match.currentId);
            });
            
            // Ø¥Ø¶Ø§ÙØ© ÙƒØ§Ø¦Ù†Ø§Øª Ø¬Ø¯ÙŠØ¯Ø© ØºÙŠØ± Ù…Ø«Ø¨ØªØ©
            currentDetections.forEach((obj, objectId) => {
                stabilizedObjects.set(objectId, {
                    id: objectId,
                    category: obj.category,
                    displayName: obj.displayName,
                    confidence: obj.confidence,
                    position: { x: obj.position.x, y: obj.position.y },
                    size: { width: obj.size.width, height: obj.size.height },
                    lastSeen: currentTime,
                    stability: 0.2 // Ø¨Ø¯Ø§ÙŠØ© Ø£Ø¹Ù„Ù‰ Ù„Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø±
                });
            });
            
            // ØªÙ†Ø¸ÙŠÙ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
            const staleIds = [];
            stabilizedObjects.forEach((obj, id) => {
                if (currentTime - obj.lastSeen > 2000) { // 2 Ø«Ø§Ù†ÙŠØ© ÙÙ‚Ø· (Ø£Ø³Ø±Ø¹ ØªÙ†Ø¸ÙŠÙ)
                    staleIds.push(id);
                }
            });
            
            staleIds.forEach(id => {
                stabilizedObjects.delete(id);
                proKalmanFilters.delete(id);
            });
            
            // ØªØ­Ø¯ÙŠØ« Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø± Ø§Ù„Ø¹Ø§Ù…
            updateStabilityLevel();
        }
        
        // ØªØ­Ø¯ÙŠØ« Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø± Ø§Ù„Ø¹Ø§Ù…
        function updateStabilityLevel() {
            let totalStability = 0;
            let count = stabilizedObjects.size;
            
            if (count === 0) {
                document.getElementById('stabilityLevel').textContent = '0%';
                return;
            }
            
            stabilizedObjects.forEach(obj => {
                totalStability += obj.stability;
            });
            
            const avgStability = (totalStability / count) * 100;
            document.getElementById('stabilityLevel').textContent = `${avgStability.toFixed(1)}%`;
        }

        async function predictWebcam() {
            if (!isDetecting || video.paused || video.ended || video.readyState < 2) {
                 requestAnimationFrame(predictWebcam);
                 return;
            }
            
            const startTime = performance.now();
            let detections = [];

            try {
                detections = await performDetection();
            } catch (error) {
                console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ÙƒØ´Ù:', error);
                requestAnimationFrame(predictWebcam);
                return;
            }

            // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù€ FPS
            frameCount++;
            const currentTime = Date.now();
            if (currentTime - lastFrameTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFrameTime = currentTime;
                document.getElementById('fps').textContent = `FPS: ${fps}`;
                document.getElementById('fpsValue').textContent = fps;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (detections.length > 0) {
                // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ«Ø¨ÙŠØª Ø¥Ø°Ø§ ÙƒØ§Ù† Ù†Ø´Ø·Ø§Ù‹
                if (stabilizationActive) {
                    matchStabilizedObjects(detections);
                }
                
                if (advancedAnalysis) {
                    analyzeObjects(detections);
                }
                
                drawDetections(detections);
                
                if (document.getElementById('statsPanel').classList.contains('hidden') === false) { 
                    updateDetectionsList(detections);
                }
                document.getElementById('objectCount').textContent = detections.length;
                document.getElementById('trackedObjects').textContent = advancedAnalysis ? trackedObjects.size : 'N/A';
            } else {
                document.getElementById('objectCount').textContent = '0';
                document.getElementById('trackedObjects').textContent = '0';
                if(isDetecting) {
                   document.getElementById('detectionsList').innerHTML = '<div class="loading"><p>Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ø´ÙŠØ§Ø¡ Ù…ÙƒØªØ´ÙØ©</p></div>';
                }
            }

            // Ø­Ø³Ø§Ø¨ ÙˆÙ‚Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©
            const processingTime = performance.now() - startTime;
            document.getElementById('processingTime').textContent = processingTime.toFixed(2);

            requestAnimationFrame(predictWebcam);
        }

        function analyzeObjects(detections) {
            const currentTime = Date.now();
            let currentDetectedIds = new Set();
            
            detections.forEach((detection, index) => {
                const bbox = detection.boundingBox;
                const confidence = detection.confidence;
                
                const centerX = bbox.originX + bbox.width / 2;
                const centerY = bbox.originY + bbox.height / 2;
                
                const objectId = `${detection.categoryName}-${index}`; 
                currentDetectedIds.add(objectId);
                
                if (!objectHistory.has(objectId)) {
                    objectHistory.set(objectId, []);
                }
                
                const history = objectHistory.get(objectId);
                history.push({
                    x: centerX,
                    y: centerY,
                    width: bbox.width,
                    height: bbox.height,
                    timestamp: currentTime
                });
                
                // Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ ØªØ§Ø±ÙŠØ® Ø£Ù‚ØµØ± Ù„ØªØ­Ù„ÙŠÙ„ Ø£ÙƒØ«Ø± Ø§Ø³ØªØ¬Ø§Ø¨Ø©
                if (history.length > 15) {
                    history.shift();
                }
                
                if (history.length > 1) {
                    const lastPoint = history[history.length - 2];
                    const currentPoint = history[history.length - 1];
                    const timeDiff = currentPoint.timestamp - lastPoint.timestamp;
                    
                    if (timeDiff > 0) {
                        const dx = currentPoint.x - lastPoint.x;
                        const dy = currentPoint.y - lastPoint.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const speed = distance / timeDiff; 
                        const direction = Math.atan2(dy, dx) * 180 / Math.PI;
                        
                        trackedObjects.set(objectId, {
                            id: objectId,
                            category: detection.categoryName,
                            displayName: detection.displayName,
                            confidence: confidence,
                            position: { x: centerX, y: centerY },
                            velocity: { dx, dy, speed },
                            direction: direction,
                            size: { width: bbox.width, height: bbox.height },
                            lastSeen: currentTime
                        });
                        
                        analyzeMovementPattern(objectId, dx, dy, speed);
                    }
                }
            });
            
            cleanupOldObjects(currentTime, currentDetectedIds);
        }
        
        function analyzeMovementPattern(objectId, dx, dy, speed) {
            if (!movementPatterns[objectId]) {
                movementPatterns[objectId] = { 
                    totalMovement: 0, 
                    directionChanges: 0, 
                    lastDirection: null, 
                    speedChanges: 0, 
                    lastSpeed: null,
                    movementHistory: []
                };
            }
            
            const pattern = movementPatterns[objectId];
            pattern.totalMovement++;
            
            const currentDirection = Math.atan2(dy, dx);
            if (pattern.lastDirection !== null) {
                const directionDiff = Math.abs(currentDirection - pattern.lastDirection);
                if (directionDiff > Math.PI / 6) { // Ø¹ØªØ¨Ø© Ø£Ù‚Ù„ Ù„ØªØºÙŠÙŠØ± Ø§Ù„Ø§ØªØ¬Ø§Ù‡
                    pattern.directionChanges++;
                }
            }
            pattern.lastDirection = currentDirection;
            
            if (pattern.lastSpeed !== null) {
                const speedDiff = Math.abs(speed - pattern.lastSpeed);
                if (speedDiff > 0.3) { // Ø¹ØªØ¨Ø© Ø£Ù‚Ù„ Ù„ØªØºÙŠÙŠØ± Ø§Ù„Ø³Ø±Ø¹Ø©
                    pattern.speedChanges++;
                }
            }
            pattern.lastSpeed = speed;
            
            // Ø­ÙØ¸ ØªØ§Ø±ÙŠØ® Ø§Ù„Ø­Ø±ÙƒØ© Ù„Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
            pattern.movementHistory.push({dx, dy, speed, timestamp: Date.now()});
            if (pattern.movementHistory.length > 30) { // ØªØ§Ø±ÙŠØ® Ø£Ù‚ØµØ± Ù„ØªØ­Ù„ÙŠÙ„ Ø£Ø³Ø±Ø¹
                pattern.movementHistory.shift();
            }
            
            updateOverallMovementPattern();
        }
        
        function updateOverallMovementPattern() {
            let totalObjects = Object.keys(movementPatterns).length;
            if (totalObjects === 0) {
                document.getElementById('movementPattern').textContent = 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ';
                return;
            }
            
            let totalDirectionChanges = 0;
            let totalSpeedChanges = 0;
            let predictabilityScore = 0;
            
            for (const objectId in movementPatterns) {
                totalDirectionChanges += movementPatterns[objectId].directionChanges;
                totalSpeedChanges += movementPatterns[objectId].speedChanges;
                
                // Ø­Ø³Ø§Ø¨ Ø¯Ø±Ø¬Ø© Ø§Ù„ØªÙˆÙ‚Ø¹ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù†ØªØ¸Ø§Ù… Ø§Ù„Ø­Ø±ÙƒØ©
                const pattern = movementPatterns[objectId];
                if (pattern.movementHistory.length > 5) { // Ø¹ØªØ¨Ø© Ø£Ù‚Ù„
                    const recentChanges = pattern.directionChanges / pattern.totalMovement;
                    predictabilityScore += (1 - recentChanges) * 100;
                }
            }
            
            const avgDirectionChanges = totalDirectionChanges / totalObjects;
            const avgSpeedChanges = totalSpeedChanges / totalObjects;
            const avgPredictability = predictabilityScore / totalObjects;
            
            let patternText = 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ';
            let color = '#00FFFF';

            if (avgDirectionChanges > 12 && avgSpeedChanges > 12) { // Ø¹ØªØ¨Ø§Øª Ø£Ù‚Ù„
                patternText = 'ğŸš¨ Ø­Ø±ÙƒØ© Ù…Ø´Ø¨ÙˆÙ‡Ø© ÙˆØ¹Ù†ÙŠÙØ©!';
                color = '#FF0000';
            } else if (avgDirectionChanges > 5 && avgSpeedChanges > 5) {
                patternText = 'âš ï¸ Ø­Ø±ÙƒØ© Ù…ØªØºÙŠØ±Ø© (ØªØ­Ù‚ÙŠÙ‚)';
                color = '#FFFF00';
            } else if (avgDirectionChanges < 3 && avgSpeedChanges < 3 && avgPredictability > 75) {
                patternText = 'âœ… Ø­Ø±ÙƒØ© Ù…Ø³ØªÙ‚Ø±Ø© / Ù…Ù†ØªØ¸Ù…Ø©';
                color = '#00FF00';
            } else if (avgPredictability > 65) {
                patternText = 'ğŸ” Ø­Ø±ÙƒØ© Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªÙˆÙ‚Ø¹';
                color = '#39FF14';
            } else {
                patternText = 'Ø´Ø¨Ù‡ Ù…Ù†ØªØ¸Ù…';
            }

            document.getElementById('movementPattern').textContent = patternText;
            document.getElementById('movementPattern').style.color = color;
        }
        
        function cleanupOldObjects(currentTime, currentDetectedIds) {
            const objectIds = Array.from(trackedObjects.keys());
            
            objectIds.forEach(objectId => {
                const object = trackedObjects.get(objectId);
                
                if (!currentDetectedIds.has(objectId) && currentTime - object.lastSeen > 1500) { // ØªÙ†Ø¸ÙŠÙ Ø£Ø³Ø±Ø¹
                    trackedObjects.delete(objectId);
                    objectHistory.delete(objectId);
                    delete movementPatterns[objectId];
                }
            });
        }

        // Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ù…Ø­Ø¯Ø«Ø© Ù…Ø¹ Ø¯Ø¹Ù… PRO ÙˆØ§Ù„ØªØ«Ø¨ÙŠØª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
        function drawDetections(detections) {
            const videoCenterX = canvas.width / 2;
            const videoBottomY = canvas.height; 

            // Ø±Ø³Ù… Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ù…Ø«Ø¨ØªØ© Ø£ÙˆÙ„Ø§Ù‹ (Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªØ«Ø¨ÙŠØª Ù†Ø´Ø·Ø§Ù‹)
            if (stabilizationActive && stabilizedObjects.size > 0) {
                stabilizedObjects.forEach((stabilizedObj, objectId) => {
                    const colorIndex = parseInt(objectId.split('-')[1]) || 0;
                    const color = proTrackingActive ? 
                                 (stabilizedObj.stability > 0.7 ? colors[10] : colors[11]) : // Ø£Ù„ÙˆØ§Ù† PRO
                                 colors[colorIndex % colors.length];
                    
                    // Ø±Ø³Ù… Ù…Ø±Ø¨Ø¹ Ø§Ù„ÙƒØ§Ø¦Ù† Ø§Ù„Ù…Ø«Ø¨Øª
                    const bboxX = stabilizedObj.position.x - stabilizedObj.size.width / 2;
                    const bboxY = stabilizedObj.position.y - stabilizedObj.size.height / 2;
                    
                    // ØªØ­Ø¯ÙŠØ¯ Ø³Ù…Ø§ÙƒØ© Ø§Ù„Ø­Ø¯ÙˆØ¯ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø±
                    const borderWidth = 3 + (stabilizedObj.stability * 5);
                    
                    // Ø±Ø³Ù… Ù…Ø±Ø¨Ø¹ Ø§Ù„ØªØ«Ø¨ÙŠØª Ù…Ø¹ ØªØ£Ø«ÙŠØ±Ø§Øª Ø¨ØµØ±ÙŠØ© Ù…Ø­Ø³Ù†Ø©
                    ctx.strokeStyle = color;
                    ctx.lineWidth = borderWidth;
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 20 + (stabilizedObj.stability * 15);
                    
                    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø± Ø¹Ø§Ù„ÙŠØ§Ù‹ØŒ Ù†Ø±Ø³Ù… Ù…Ø±Ø¨Ø¹Ø§Ù‹ Ù…Ø²Ø¯ÙˆØ¬Ø§Ù‹
                    if (stabilizedObj.stability > 0.7) {
                        ctx.strokeRect(bboxX - 3, bboxY - 3, stabilizedObj.size.width + 6, stabilizedObj.size.height + 6);
                    }
                    
                    ctx.strokeRect(bboxX, bboxY, stabilizedObj.size.width, stabilizedObj.size.height);
                    ctx.shadowBlur = 0;
                    
                    // Ø±Ø³Ù… Ø®Ø· Ø§Ù„ØªØªØ¨Ø¹ Ø§Ù„Ù…Ø±ÙƒØ²ÙŠ Ù„Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ù…Ø«Ø¨ØªØ©
                    if (showAimbotLines) {
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 2 + stabilizedObj.stability * 2;
                        ctx.shadowColor = color;
                        ctx.shadowBlur = 15;

                        ctx.beginPath();
                        ctx.moveTo(videoCenterX, videoBottomY);
                        ctx.lineTo(stabilizedObj.position.x, stabilizedObj.position.y);
                        ctx.stroke();

                        ctx.shadowBlur = 0;
                    }
                    
                    // Ø±Ø³Ù… Ø´Ø±ÙŠØ· Ø§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø±
                    const stabilityBarWidth = stabilizedObj.size.width;
                    const stabilityBarHeight = 8;
                    const stabilityBarY = bboxY - 15;
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(bboxX, stabilityBarY, stabilityBarWidth, stabilityBarHeight);
                    
                    const stabilityFillWidth = stabilizedObj.stability * stabilityBarWidth;
                    const stabilityColor = stabilizedObj.stability > 0.7 ? '#00FF00' : 
                                          (stabilizedObj.stability > 0.4 ? '#FFFF00' : '#FF0000');
                    ctx.fillStyle = stabilityColor;
                    ctx.fillRect(bboxX, stabilityBarY, stabilityFillWidth, stabilityBarHeight);
                    
                    // Ø±Ø³Ù… Ù†Øµ Ø§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø±
                    const proPrefix = proTrackingActive ? 'ğŸ¦¾ ' : '';
                    const label = `${proPrefix}${stabilizedObj.displayName} [${(stabilizedObj.confidence * 100).toFixed(1)}%] - ${(stabilizedObj.stability * 100).toFixed(0)}%`;
                    ctx.font = `bold ${14 + stabilizedObj.stability * 6}px Consolas`;
                    const textWidth = ctx.measureText(label).width;
                    
                    let textX = bboxX;
                    let textY = stabilityBarY - 5;
                    
                    if (textY < 0) {
                        textY = bboxY + 20;
                    }

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(textX, textY - 18, textWidth + 10, 22);

                    ctx.fillStyle = color;
                    ctx.fillText(label, textX + 5, textY);
                    
                    // Ø±Ø³Ù… Ù…Ø±ÙƒØ² Ø§Ù„ÙƒØ§Ø¦Ù† Ø§Ù„Ù…Ø«Ø¨Øª
                    ctx.fillStyle = color;
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 20 + (stabilizedObj.stability * 15);
                    ctx.beginPath();
                    ctx.arc(stabilizedObj.position.x, stabilizedObj.position.y, 6 + (stabilizedObj.stability * 6), 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    // Ø±Ø³Ù… Ù…Ø³Ø§Ø± Ø§Ù„Ø­Ø±ÙƒØ© Ù„Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ù…Ø«Ø¨ØªØ©
                    if (advancedAnalysis) {
                        const objectId = stabilizedObj.id;
                        const history = objectHistory.get(objectId);
                        
                        if (history && history.length > 1) {
                            // Ø±Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø³Ø§Ø¨Ù‚
                            ctx.strokeStyle = color;
                            ctx.lineWidth = 2 + stabilizedObj.stability;
                            ctx.setLineDash([4, 4]);
                            ctx.beginPath();
                            ctx.moveTo(history[0].x, history[0].y);
                            
                            for (let i = 1; i < history.length; i++) {
                                ctx.lineTo(history[i].x, history[i].y);
                            }
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }
                    }
                });
            }
            
            // Ø±Ø³Ù… Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ù…ÙƒØªØ´ÙØ© Ø­Ø¯ÙŠØ«Ø§Ù‹ (Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ø§Ù„ØªØ«Ø¨ÙŠØª Ù†Ø´Ø·Ø§Ù‹ Ø£Ùˆ Ù„Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø©)
            if (!stabilizationActive || performanceEnhanced) {
                detections.forEach((detection, index) => {
                    const bbox = detection.boundingBox;
                    const color = colors[index % colors.length];
                    const confidence = (detection.confidence * 100).toFixed(1);

                    const centerX = bbox.originX + bbox.width / 2;
                    const centerY = bbox.originY + bbox.height / 2;
                    
                    // Ø±Ø³Ù… Ø®Ø· Ø§Ù„ØªØªØ¨Ø¹ Ø§Ù„Ù…Ø±ÙƒØ²ÙŠ
                    if (showAimbotLines) {
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 3;
                        ctx.shadowColor = color;
                        ctx.shadowBlur = 15;

                        ctx.beginPath();
                        ctx.moveTo(videoCenterX, videoBottomY);
                        ctx.lineTo(centerX, centerY);
                        ctx.stroke();

                        ctx.shadowBlur = 0;
                    }

                    // Ø±Ø³Ù… Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ù…Ø­ÙŠØ·
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 4;
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 12;
                    ctx.strokeRect(bbox.originX, bbox.originY, bbox.width, bbox.height);
                    ctx.shadowBlur = 0;
                    
                    // Ø±Ø³Ù… Ø´Ø±ÙŠØ· Ø§Ù„Ø«Ù‚Ø©
                    const healthBarWidth = bbox.width;
                    const healthBarHeight = 6;
                    const healthBarY = bbox.originY - 18;
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(bbox.originX, healthBarY, healthBarWidth, healthBarHeight);
                    
                    const healthFillWidth = (confidence / 100) * healthBarWidth;
                    ctx.fillStyle = confidence > 70 ? '#00FF00' : (confidence > 40 ? '#FFFF00' : '#FF0000');
                    ctx.fillRect(bbox.originX, healthBarY, healthFillWidth, healthBarHeight);
                    
                    // Ø±Ø³Ù… Ù…Ø±ÙƒØ² Ø§Ù„ÙƒØ´Ù
                    ctx.fillStyle = color;
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 6, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.shadowBlur = 0;

                    // Ø±Ø³Ù… Ø´Ø±ÙŠØ· Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª
                    const label = `${detection.displayName} [${confidence}%]`;
                    ctx.font = 'bold 16px Consolas';
                    const textWidth = ctx.measureText(label).width;
                    
                    let textX = bbox.originX;
                    let textY = healthBarY - 8;
                    
                    if (textY < 0) {
                        textY = bbox.originY + 20;
                    }

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(textX, textY - 18, textWidth + 10, 22);

                    ctx.fillStyle = color;
                    ctx.fillText(label, textX + 5, textY);
                    
                    // Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…: Ù…Ø³Ø§Ø± Ø§Ù„Ø­Ø±ÙƒØ© ÙˆØ§Ù„ØªÙˆÙ‚Ø¹
                    if (advancedAnalysis) {
                        const objectId = `${detection.categoryName}-${index}`;
                        const history = objectHistory.get(objectId);
                        
                        if (history && history.length > 1) {
                            // Ø±Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø³Ø§Ø¨Ù‚
                            ctx.strokeStyle = color;
                            ctx.lineWidth = 2;
                            ctx.setLineDash([4, 4]);
                            ctx.beginPath();
                            ctx.moveTo(history[0].x, history[0].y);
                            
                            for (let i = 1; i < history.length; i++) {
                                ctx.lineTo(history[i].x, history[i].y);
                            }
                            ctx.stroke();
                            ctx.setLineDash([]);
                            
                            // Ø±Ø³Ù… ØªÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø³Ø§Ø±
                            if (history.length >= 3) {
                                const lastPoint = history[history.length - 1];
                                const prevPoint = history[history.length - 2];
                                
                                const dx = lastPoint.x - prevPoint.x;
                                const dy = lastPoint.y - prevPoint.y;
                                
                                ctx.strokeStyle = '#FFFF00';
                                ctx.lineWidth = 2;
                                ctx.setLineDash([2, 5]);
                                ctx.beginPath();
                                ctx.moveTo(lastPoint.x, lastPoint.y);
                                ctx.lineTo(lastPoint.x + dx * 5, lastPoint.y + dy * 5);
                                ctx.stroke();
                                ctx.setLineDash([]);
                            }
                        }
                    }
                });
            }
        }
        
        function updateDetectionsList(detections) {
            const listHTML = detections.map((detection, index) => {
                const bbox = detection.boundingBox;
                const color = colors[index % colors.length];
                const confidence = (detection.confidence * 100).toFixed(1);
                
                let advancedInfo = '';
                if (advancedAnalysis) {
                    const objectId = `${detection.categoryName}-${index}`;
                    const trackedObject = trackedObjects.get(objectId);
                    
                    if (trackedObject) {
                        advancedInfo = `
                            <div>ğŸš€ Ø§Ù„Ø³Ø±Ø¹Ø©: ${trackedObject.velocity.speed.toFixed(3)} Ø¨ÙƒØ³Ù„/Ù…Ù„Ù„ÙŠ Ø«Ø§Ù†ÙŠØ©</div>
                            <div>ğŸ§­ Ø§Ù„Ø§ØªØ¬Ø§Ù‡: ${trackedObject.direction.toFixed(1)}Â°</div>
                        `;
                    }
                }

                // Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªØ«Ø¨ÙŠØª Ø¥Ø°Ø§ ÙƒØ§Ù† Ù†Ø´Ø·Ø§Ù‹
                let stabilizationInfo = '';
                if (stabilizationActive) {
                    const objectId = `${detection.categoryName}-${index}`;
                    const stabilizedObj = stabilizedObjects.get(objectId);
                    if (stabilizedObj) {
                        stabilizationInfo = `
                            <div>ğŸ¯ Ø§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø±: ${(stabilizedObj.stability * 100).toFixed(1)}%</div>
                        `;
                    }
                }

                return `
                    <div class="detection-item" style="border-color: ${color}">
                        <div class="detection-name" style="color: ${color}; text-shadow: 0 0 3px ${color}">
                            ${proTrackingActive ? 'ğŸ¦¾ ' : ''}${index + 1}. ${detection.displayName}
                        </div>
                        <div class="detection-details">
                            <div>ğŸ“ Ø§Ù„Ù…ÙˆÙ‚Ø¹: (${bbox.originX.toFixed(0)}, ${bbox.originY.toFixed(0)})</div>
                            <div>ğŸ“ Ø§Ù„Ø­Ø¬Ù…: ${bbox.width.toFixed(0)}Ã—${bbox.height.toFixed(0)}</div>
                            <div>ğŸ¯ Ø§Ù„Ø«Ù‚Ø©: ${confidence}%</div>
                            ${advancedInfo}
                            ${stabilizationInfo}
                        </div>
                        <div class="confidence-bar">
                            <div class="confidence-fill" style="width: ${confidence}%; background: ${color}; box-shadow: 0 0 5px ${color}"></div>
                        </div>
                    </div>
                `;
            }).join('');

            document.getElementById('detectionsList').innerHTML = listHTML;
        }

        function captureImage() {
            const captureCanvas = document.createElement('canvas');
            captureCanvas.width = canvas.width;
            captureCanvas.height = canvas.height;
            const captureCtx = captureCanvas.getContext('2d');
            
            captureCtx.drawImage(video, 0, 0, canvas.width, canvas.height);
            captureCtx.drawImage(canvas, 0, 0);
            
            captureCanvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `pro-tracking-${Date.now()}.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
        }
        
        function toggleStatsPanel() {
            const statsPanel = document.getElementById('statsPanel');
            const mainContent = document.getElementById('mainContent'); 
            const toggleStatsBtn = document.getElementById('toggleStatsBtn');
            
            const statsVisible = !statsPanel.classList.contains('hidden');
            
            if (statsVisible) {
                statsPanel.classList.add('hidden');
                mainContent.classList.add('full-width');
                toggleStatsBtn.textContent = 'ğŸ‘ï¸ Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª';
            } else {
                statsPanel.classList.remove('hidden');
                mainContent.classList.remove('full-width');
                toggleStatsBtn.textContent = 'ğŸ‘ï¸ Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª';
            }
        }
        
        function updateSystemStatus(elementId, status) {
            const element = document.getElementById(elementId);
            element.className = 'status-dot';
            
            if (status === 'online') {
                element.classList.add('status-online');
            } else if (status === 'processing') {
                element.classList.add('status-processing');
            } else if (status === 'pro') {
                element.classList.add('status-pro');
            } else {
                element.classList.add('status-offline');
            }
        }

        // Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
        document.getElementById('enableCameraBtn').addEventListener('click', enableCamera);
        document.getElementById('stopCameraBtn').addEventListener('click', stopCamera);
        document.getElementById('switchCameraBtn').addEventListener('click', switchCamera);
        document.getElementById('captureBtn').addEventListener('click', captureImage);
        document.getElementById('toggleStatsBtn').addEventListener('click', toggleStatsPanel);
        document.getElementById('aiAnalysisBtn').addEventListener('click', toggleAdvancedAnalysis);
        document.getElementById('toggleAimbotLinesBtn').addEventListener('click', toggleAimbotLines);
        document.getElementById('stabilizeBtn').addEventListener('click', toggleStabilization);
        document.getElementById('enhancePerformanceBtn').addEventListener('click', togglePerformanceEnhancement);
        document.getElementById('proTrackingBtn').addEventListener('click', toggleProTracking);

        // Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„ÙƒØ´Ù
        document.querySelectorAll('input[name="detectionType"]').forEach(radio => {
            radio.addEventListener('change', updateDetectionType);
        });

        // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù†Ø¸Ø§Ù… Ø¹Ù†Ø¯ Ø§Ù„ØªØ­Ù…ÙŠÙ„
        initializeDetectors();
        
        // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø£ÙˆÙ„ÙŠØ©
        updateSystemStatus('systemStatus', 'offline');
        updateSystemStatus('aiStatus', 'offline');
        updateSystemStatus('trackingStatus', 'offline');
        updateSystemStatus('stabilizeStatus', 'offline');
        updateSystemStatus('performanceStatus', 'offline');
        updateSystemStatus('proStatus', 'offline');
    </script>
</body>
  </html>
